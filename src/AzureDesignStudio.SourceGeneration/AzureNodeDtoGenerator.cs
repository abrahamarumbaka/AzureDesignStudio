using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Linq;

namespace AzureDesignStudio.SourceGeneration
{
    [Generator]
    public class AzureNodeDtoGenerator : ISourceGenerator
    {
        private readonly DiagnosticDescriptor _errorDescriptor = new("ADS001",
            "ADS001: Error in source generation", "Error in source generator<{0}>: '{1}'", "SourceGenerator",
            DiagnosticSeverity.Error, true);
        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new DtoGeneratorSyntaxReceiver());
        } 
        
        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not DtoGeneratorSyntaxReceiver dtoReceiver)
                return;

            if (string.IsNullOrEmpty(dtoReceiver.DtoNamespace))
            {
                context.ReportDiagnostic(Diagnostic.Create(_errorDescriptor, Location.None, "Dto namespace not found."));
                return;
            }

            foreach (var model in dtoReceiver.ModelTypes)
            {
                var className = $"{model.Identifier.Text}Dto";
                var classDecl = CreateClassDeclaration(className);

                foreach(var member in model.Members)
                {
                    if (member is PropertyDeclarationSyntax propSyntax && propSyntax.HasAttribute("MapToDto"))
                    {
                        classDecl = classDecl.AddMembers(CreatePropertyDeclaration(propSyntax));
                    }
                }
                var namespaceDecl = CreateNamespaceDeclaration(model.GetNamespace())
                    .AddMembers(classDecl);

                var source = GenerateSource(namespaceDecl, dtoReceiver.DtoNamespace!);

                context.AddSource($"{className}.g.cs", source);
            }
        }

        private ClassDeclarationSyntax CreateClassDeclaration(string className)
        {
            return SyntaxFactory.ClassDeclaration(className)
                .AddModifiers(
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword)
                )
                .AddBaseListTypes(SyntaxFactory.SimpleBaseType(SyntaxFactory.ParseTypeName("AzureNodeDto")));
        }

        private PropertyDeclarationSyntax CreatePropertyDeclaration(PropertyDeclarationSyntax propSyntax)
        {
            return SyntaxFactory.PropertyDeclaration(propSyntax.Type, propSyntax.Identifier)
                .AddModifiers(propSyntax.Modifiers.ToArray())
                .AddAccessorListAccessors(propSyntax.AccessorList!.Accessors.ToArray());
        }

        private NamespaceDeclarationSyntax CreateNamespaceDeclaration(string namespaceName)
        {
            return SyntaxFactory.NamespaceDeclaration(
                SyntaxFactory.IdentifierName(namespaceName));
        }

        private string GenerateSource(NamespaceDeclarationSyntax namespaceDecl, string dtoNamespace)
        {
            CompilationUnitSyntax compilationUnit = SyntaxFactory.CompilationUnit()
                .AddMembers(namespaceDecl);

            compilationUnit = compilationUnit.AddUsings(
                SyntaxFactory.UsingDirective(MakeQualifiedName("System.Collections.Generic")),
                SyntaxFactory.UsingDirective(MakeQualifiedName(dtoNamespace)));

            compilationUnit = compilationUnit.WithLeadingTrivia(
                SyntaxFactory.ParseLeadingTrivia(@"// <auto-generated>
//     This code was generated by a source generation.
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>"));

            return compilationUnit.NormalizeWhitespace().GetText().ToString();
        }

        private static NameSyntax MakeQualifiedName(string dottedName)
        {
            string[] components = dottedName.Split(new[] { '.' });
            NameSyntax qualifiedName = SyntaxFactory.ParseName(components[0]);
            for (int i = 1; i < components.Length; ++i)
            {
                qualifiedName = SyntaxFactory.QualifiedName(qualifiedName, SyntaxFactory.IdentifierName(components[i]));
            }

            return qualifiedName;
        }
    }
}
